*ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。*

**解构赋值不仅适用于 `var` 命令，也适用于`let`和`const`命令**

## 2.1.数组的解构赋值

**只要等号两边的模式相同，左边的变量就会被赋予对应的值。等号右边的值需要具备 `Iterator` 接口，才能赋值成功**

```

let [ foo, [[bar]], baz ] = [ 1, [[2]], 3 ];

console.log( foo ); // 1
console.log( bar ); // 2
console.log( baz ); // 3

let [ , , third ] =  ["foo", "bar", "baz" ];
console.log( third ); // baz

let [ head, ...tail ] = [ 1, 2, 3, 4 ];
console.log( head ); // 1
console.log( tail ); // [ 2, 3, 4 ]

//如果解构不成功，变量的值等于undefined

//不完全解构，但能成功
let [ x, y  ] = [ 1, 2, 3 ];
console.log( x ); // 1
console.log( y ); // 2

//解构赋值允许指定默认值
//ES6内部使用严格相等运算符（===），判断一个位置是否有值，
//如果一个数组成员不严格等于undefined,默认值是不会生效的
var [ yee = true ] = [];
console.log( yee ) // true;

{
	let [ x, y = 'b' ] = [ 'a' ];
	console.log( x ); // a
	console.log( y ); // b
}
{
	let [ x, y = 'b' ] = [ 'a', undefined ];
	console.log( x ); // a
	console.log( y ); // b
}
{
	let [ x = 1 ] = [undefined];
	console.log( x ); // 1

	let [ y = 2 ] = [null];
	console.log( y ) // 2;
}

//如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值
{
	function f(){
		console.log( "hello" );
	}
	let[ x = f() ] = [1]; //
	let[ y = f() ] = []; //hello
}
//默认值可以应用解构赋值的其他变量，但是该变量必须已经声明
{
	let [ x = 1, y = x ] = []; //x=1;y=1;
	let [ x = y, y = 1 ] = []; //ReferenceError
}
```

## 2.2.对象的解构赋值
> 对象解构赋值与数组的一个重要不同点：数组的元素是按次序列表排列的，变量的取值由位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```
{
	//变量名与属性名一致
	let { foo, bar } = { foo: "hello", bar: "world" };
	let { baz } = { foo: "aaa", bar: "bbb" };
	console.log( "foo: " + foo ); //foo:hello
	console.log( "bar: " + bar ); //bar:world
	console.log( "baz: " + baz ); //baz:undefined
}
{
	//变量名与属性名不一致
	let { foo: baz } = { foo: "aaa", bar: "bbb" };
	console.log( "baz: " + baz ); //baz: aaa
	let { first: f, last: l } = { first: "xiao", last: "zhao" }
	console.log( "f: " + f ); //f:xiao
	console.log( "l: " + l ); //l:zhao
}
```
> 第二个例子说明了对象的解构赋值是下面形式的简写
> var { foo: foo, baz: baz } = { foo: "hello", baz: "world" };
> 对象的解构赋值内部机制，是先找到同名属性，然后在赋给对应的变量，真正被赋值的是后者，前者是模型，后者是变量，模型是不能被赋值的

**对于 `let` 和 `const` 来说，变量不能重新声明，所以一旦赋值的变量是以前声明过，就会报错**

```
{
	let foo;
	let { foo } = { foo: "?" }; //ReferenceError
}
```
可以换成下面的写法
```
{
	let foo;
	( { foo } = { foo: "?" } );
	console.log( "foo: " + foo ); //foo: ?
}
```

对象解构赋值同样可以嵌套结构的对象
```
{
	let obj = {
		p: [
			"hello",
			{ y: "world" }
		]
	};

	let { p: [ x, { y } ] } = obj;
	console.log( "x: "+ x ); //x: hello
	console.log( "y: "+ y ); //y: world
}
```

对象解构指定默认值，只有当等号右边对象对应属性值严格等于 `undefined` 时，默认值才有效
```
{
	let { message: msg = "Something went wrong" } = {};
	let { x = 1, y = 2 } = { y: 5 };
	let { n = 3 } = { n: null };
	console.log( msg ); //Something went wrong
	console.log( "x: " + x ); //x: 1
	console.log( "y: " + y ); //y: 5
	console.log( "n: " + n ); //n: null
}
```
> 注意：`null` 不严格等于 undefined ，所以上例中 n 是取 `null` 值

下例中，由于 foo 等于 undefined ，解析 bar 是会报错
```
var {foo: {bar}} = {baz: 'baz'};
```

对一个已经声明的变量用解构赋值时可能会报错
```
var x;
{x} = {x: 1}; //ReferenceError
```
> js将 {x} 理解成了一个代码块，从而发生语法错误，只有不将大括号写在行首，避免js将其解释为代码块，就不会报错，如下面例子：
```
var x;
({x} = {x: 1}); //正确
//下面语法也是合法的
({} = [true, false]);
({} = 'abc');
({} = []);
```

**对象的解构赋值的用法**
```
let { log, sin, cos } = Math;
```
将Math对象的对数、正弦、余弦三个方法赋值给对应的变量，使用起来更方便
